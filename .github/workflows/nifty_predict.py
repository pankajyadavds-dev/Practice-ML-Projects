# -*- coding: utf-8 -*-
"""Nifty_predict.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Drw--gfSXuzWC8lRmqQPBtazQSGVIN6G
"""

"""pip install yfinance pandas scikit-learn lightgbm numpy
"""

import yfinance as yf
import pandas as pd
import numpy as np
from sklearn.model_selection import TimeSeriesSplit
from sklearn.metrics import mean_absolute_error
from lightgbm import LGBMRegressor
import warnings
warnings.filterwarnings("ignore")

"Column Name Cleaning Function"
def clean_column_names(df):
    """Clean column names to be compatible with LightGBM"""
    cleaned_columns = []
    for col in df.columns:
        if isinstance(col, tuple):
            # If it's a tuple (MultiIndex), convert to string first
            col = '_'.join(map(str, col))
        # Replace unwanted chars in string column name
        col = col.replace(' ', '_').replace('^', '').replace('-', '_')
        cleaned_columns.append(col)
    df.columns = cleaned_columns
    return df

"""# 1. Data download"""

from pickle import NONE
TICKER = "^NSEI"          # Yahoo symbol for NIFTY 50
START  = "2021-01-01"
END    = None       # up to today

# After downloading data from yfinance
nifty = yf.download(TICKER, start=START, end=END, progress=False)
#nifty = clean_column_names(nifty)  # ← ADD THIS LINE
nifty = nifty.dropna()

nifty.head()

"""2. Feature engineering
#    – Lagged returns
#    – Rolling statistics
#    – Calendar effects
"""

def make_features(df: pd.DataFrame) -> pd.DataFrame:
    X = df.copy()
    # Percentage returns
    X["ret_1"]   = X["Close"].pct_change(1)
    X["ret_3"]   = X["Close"].pct_change(3)
    X["ret_5"]   = X["Close"].pct_change(5)
    # Rolling means & stds
    X["sma_5"]   = X["Close"].rolling(5).mean()
    X["sma_10"]  = X["Close"].rolling(10).mean()
    X["sma_20"]  = X["Close"].rolling(20).mean()
    X["std_5"]   = X["Close"].rolling(5).std()
    X["std_10"]  = X["Close"].rolling(10).std()
    # Calendar features
    X["dow"]     = X.index.dayofweek          # 0-Mon … 4-Fri
    X["month"]   = X.index.month
    # Drop rows with NaNs created by rolling windows
    X = X.dropna()
    y = X["Close"].shift(-1).dropna()         # tomorrow’s close
    X = X.loc[y.index]                        # align X and y
    return X, y

X, y = make_features(nifty)

tscv = TimeSeriesSplit(n_splits=5)
preds, trues = [], []
for train_idx, val_idx in tscv.split(X):
    X_train, X_val = X.iloc[train_idx], X.iloc[val_idx]
    y_train, y_val = y.iloc[train_idx], y.iloc[val_idx]
    if isinstance(y_val, pd.DataFrame):
        y_val = y_val.iloc[:, 0]
    # Clean column names (see earlier answer)
    X_train = clean_column_names(X_train)
    X_val = clean_column_names(X_val)

    model = LGBMRegressor(
        n_estimators=500,
        learning_rate=0.02,
        max_depth=-1,
        subsample=0.8,
        colsample_bytree=0.8,
        random_state=42,
    )
    model.fit(X_train, y_train)
    fold_preds = model.predict(X_val)
    # Use .extend for lists, or .append for arrays (numpy)
    preds.extend(list(fold_preds))
    trues.extend(list(y_val))  # Make sure this is also an iterable

print(type(fold_preds), type(y_val), len(fold_preds), len(y_val))

print(f"Fold prediction shape: {X_val.shape}")
print(f"Fold y_val shape: {y_val.shape}")

print(f"Length trues: {len(trues)}, Length preds: {len(preds)}")
print(f"Walk-forward MAE: {mean_absolute_error(preds,trues):.2f} points")

# 4. Retrain on full history and predict tomorrow
# ---------------------------------------------------------------------------
X = clean_column_names(X)
model_final = LGBMRegressor(
    n_estimators=500,
    learning_rate=0.02,
    max_depth=-1,
    subsample=0.8,
    colsample_bytree=0.8,
    random_state=42,
)
model_final.fit(X, y)
# 1. Get Today’s Close as a pure float
today_close = float(nifty["Close"].iloc[-1])

# 2. Predict next-day close and extract scalar
X_last, _ = make_features(nifty.tail(60))
X_last = clean_column_names(X_last)
next_day_pred = model_final.predict(X_last.tail(1))[0]  # returns numpy.float64
next_day_pred = float(next_day_pred)                    # convert to float

# 3. Compute ATM strike
def round_to_nearest_50(x):
    return int(round(x / 50.0) * 50)

suggested_strike = round_to_nearest_50(next_day_pred)

# 4. Print forecast with formatting
print("\n----- Forecast -----")
print(f"Today’s close       : {today_close:,.2f}")
print(f"Predicted close     : {next_day_pred:,.2f}")
print(f"Suggested ATM strike: {suggested_strike}")